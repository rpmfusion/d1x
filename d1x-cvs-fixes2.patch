diff -urbBwN d1x.orig/arch/linux/hmiplay.c d1x/arch/linux/hmiplay.c
--- d1x.orig/arch/linux/hmiplay.c	2000-02-07 11:13:12.000000000 +0100
+++ d1x/arch/linux/hmiplay.c	2005-08-04 14:37:08.000000000 +0200
@@ -16,12 +16,14 @@
 #include <fcntl.h>
 #include <sys/types.h>
 #include <sys/ipc.h>
+#define __USE_GNU //in recent glibc versions msgbuf is only defined if you have __USE_GNU defined
 #include <sys/msg.h>
 #include "music.h"
 #include "cfile.h"
 #include "u_mem.h"
+#include "args.h"
 
-#include <SDL_thread.h>
+#include <SDL/SDL_thread.h>
 
 //#define WANT_AWE32 1
 
@@ -32,6 +34,19 @@
 //#define WANT_MPU401 1
 
 #ifdef WANT_MPU401
+
+unsigned char reset_genmidi[5] =
+	{ 0x7e, 0x7f, 0x09, 0x01, 0xf7 };
+
+#define MIDI_RESET {					\
+	SEQ_MIDIOUT(synth_dev,MIDI_SYSTEM_PREFIX);	\
+	SEQ_MIDIOUT(synth_dev,reset_genmidi[0]);	\
+	SEQ_MIDIOUT(synth_dev,reset_genmidi[1]);	\
+	SEQ_MIDIOUT(synth_dev,reset_genmidi[2]);	\
+	SEQ_MIDIOUT(synth_dev,reset_genmidi[3]);	\
+	SEQ_MIDIOUT(synth_dev,reset_genmidi[4]);	\
+}
+
 #define MIDI_MESSAGE2(a,b) {		\
 	SEQ_MIDIOUT(synth_dev,a);	\
 	SEQ_MIDIOUT(synth_dev,b);	\
@@ -60,6 +75,7 @@
 
 Voice_info *voices;
 unsigned char *data=NULL;
+char digi_last_midi_song[16] = "";
 
 struct synth_info card_info;
 
@@ -180,7 +196,8 @@
 	}
 	
 	if (card_info.synth_type==SYNTH_TYPE_MIDI) {
-		// Insert some sort of midi reset here later.
+		MIDI_RESET;
+		SEQ_DUMPBUF();
 	} else
 #endif
 #ifdef WANT_AWE32    
@@ -380,6 +397,8 @@
 #endif
 #ifdef WANT_MPU401
 	  if (card_info.synth_type==SYNTH_TYPE_MIDI) {
+		MIDI_RESET;
+		SEQ_DUMPBUF();
 	  } else
 #endif
 	{
@@ -527,7 +546,7 @@
 				     IPC_CREAT | 0660);
 		snd=malloc(sizeof(long) + 32);
 		snd->mtype=1;
-		player_thread=SDL_CreateThread(play_hmi, NULL);
+		player_thread=SDL_CreateThread((int (*)(void *))play_hmi, NULL);
 //		player_pid = play_hmi();
 	}    
 	if (strlen(message) < 16)
@@ -550,7 +569,8 @@
 int do_ipc(int qid, struct msgbuf *buf, int flags)
 {
 	int ipc_read;
-	CFILE *fptr;
+	CFILE *fptr=NULL;
+	float last_volume = volume;
 	int l=0;
 	
 	ipc_read = msgrcv(qid,buf,16,0,flags | MSG_NOERROR);
@@ -569,10 +589,24 @@
 		switch (buf->mtext[0])
 		{
 		 case 'v':
-			volume=(double) ((double) buf->mtext[0]/127.0);
+			volume=(double) (atof(buf->mtext+1)/128.0);
+			printf("vol %f->%f\n",last_volume,volume);
+			if (last_volume<=0 && volume>0) {
+				buf->mtext[0]='p';//start playing again if volume raised above 0
+				strcpy(buf->mtext+1, digi_last_midi_song);
+				//fall through to case 'p'
+			}else if (last_volume>0 && volume<=0) {
+				strcpy(buf->mtext, "s"); //stop playing if volume reduced to 0
+				stop = 2;
+				break;
+			}else
 			break;
 		 case 'p':
+			if (buf->mtext[1]) {
+				strcpy(digi_last_midi_song, buf->mtext+1);
+				if (volume>0)
 			fptr=cfopen((buf->mtext+1),"rb");		
+			}
 			if(fptr != NULL)
 			{
 				l = cfilelength(fptr);
@@ -580,8 +614,11 @@
 				cfread(data, l, 1, fptr);
 				cfclose(fptr);
 				printf ("good. fpr=%p l=%i data=%p\n", fptr, l, data);//##########3
-			}
 			stop = 0;
+			} else {
+				strcpy(buf->mtext, "s"); //not playing, thus "stop".
+				stop = 2;
+			}
 			break;
 		 case 's':
 			stop = 2;
@@ -590,6 +627,7 @@
 //			SDL_KillThread(player_thread);
 			break;  
 		}
+//		printf ("do_ipc %s ret %i\n", buf->mtext, ipc_read);//##########3
 	}
 	
 	return ipc_read;
@@ -602,7 +640,7 @@
 	int n_chunks = 0;
 	int low_dtime;
 	int low_chunk;
-	int csec;
+	int csec,lcsec;
 //	pid_t loc_pid;
 	int qid;
 	int ipc_read = 0;
@@ -635,8 +673,6 @@
 	rcv->mtype=1;
 	rcv->mtext[0]='0';
 	
-	sleep(2);
-	
 	qid=msgget ((key_t) ('l'<<24) | ('d'<<16) | ('e'<<8) | 's', 0660);
 	if(qid == -1)
 	{	
@@ -669,6 +705,8 @@
 			pos += (( (0xff & data[pos + 5]) << 8 ) + (0xff & data[pos + 4]));
 		}
 		
+		lcsec=0;
+		
 		SEQ_START_TIMER();
 		do
 		{
@@ -710,7 +748,11 @@
 				k = 0;
 			}
 			
+			if (csec != lcsec) {
 			SEQ_WAIT_TIME(csec);
+			}
+			
+			lcsec = csec;
 			
 			t_info[low_chunk].status = do_track_event(data,&t_info[low_chunk].position);
 			
@@ -761,13 +803,21 @@
 }
 
 void digi_play_midi_song( char * filename, char * melodic_bank, char * drum_bank, int loop ) {
-        char buf[128];
+	if(FindArg("-nomusic"))
+		return;
     
+	if (!filename)
+		send_ipc("p");
+	else {
+		char buf[128];
         sprintf(buf,"p%s",filename);
         send_ipc(buf);
 }
+}
 void digi_set_midi_volume( int mvolume ) { 
         char buf[128];
+	if(FindArg("-nomusic"))
+		return;
     
         sprintf(buf,"v%i",mvolume);
         send_ipc(buf);
diff -urbBwN d1x.orig/arch/linux/joystick.c d1x/arch/linux/joystick.c
--- d1x.orig/arch/linux/joystick.c	2000-10-27 06:49:22.000000000 +0200
+++ d1x/arch/linux/joystick.c	2005-08-04 14:37:08.000000000 +0200
@@ -1,6 +1,6 @@
 #include <stdlib.h>
 #include <stdio.h>
-#include "joystick.h"
+#include <linux/joystick.h>
 #include <sys/ioctl.h>
 #include <fcntl.h>
 #include <unistd.h>
@@ -162,6 +162,7 @@
 ubyte joystick_read_raw_axis (ubyte mask, int *axes) {
 	int i;
 	
+	if (!joy_installed) return 0;
 	j_Update_state();
 
 	for (i = 0; i <= j_num_axes; i++) {
@@ -339,6 +340,7 @@
 
 
 int joy_get_button_state (int btn) {
+	if (!joy_installed) return 0;
   if(btn >= j_num_buttons)
    return 0;
         j_Update_state ();
@@ -350,6 +352,7 @@
 int joy_get_button_down_cnt (int btn) {
 	int downcount;
 
+	if (!joy_installed) return 0;
 	j_Update_state ();
 
 	downcount = j_button[btn].downcount;
@@ -362,6 +365,7 @@
 //changed 6/24/99 to finally squish the timedown bug - Owen Evans
 fix joy_get_button_down_time(int btn)  {
 	fix downtime;
+	if (!joy_installed) return 0;
 	j_Update_state ();
 
 	if (j_button[btn].state) {
diff -urbBwN d1x.orig/arch/sdl/clipboard.c d1x/arch/sdl/clipboard.c
--- d1x.orig/arch/sdl/clipboard.c	1970-01-01 01:00:00.000000000 +0100
+++ d1x/arch/sdl/clipboard.c	2005-08-04 14:37:08.000000000 +0200
@@ -0,0 +1,89 @@
+#include "clipboard.h"
+
+#include <SDL/SDL.h>
+#include <SDL/SDL_syswm.h>
+#include <limits.h>
+#include <string.h>
+
+//adapted by Matthew Mueller from the Scrap 1.0 example by Sam Lantinga
+// ( see http://www.libsdl.org/projects/scrap/ )
+int getClipboardText(char *text, int strlength)
+{
+	int retval = 0;
+	SDL_SysWMinfo info;
+	SDL_VERSION(&info.version);
+	if ( SDL_GetWMInfo(&info) )
+	{
+		if ( info.subsystem == SDL_SYSWM_X11 )
+		{
+			Display *SDL_Display = info.info.x11.display;
+			Window SDL_Window = info.info.x11.window;
+			void (*Lock_Display)(void) = info.info.x11.lock_func;
+			void (*Unlock_Display)(void) = info.info.x11.unlock_func;
+			
+			Window owner;
+			Atom selection;
+			Atom seln_type;
+			int seln_format;
+			unsigned long nbytes;
+			unsigned long overflow;
+			unsigned char *src;
+
+			/* Enable the special window hook events */
+			SDL_EventState(SDL_SYSWMEVENT, SDL_ENABLE);
+
+			Lock_Display();
+			owner = XGetSelectionOwner(SDL_Display, XA_PRIMARY);
+			Unlock_Display();
+			if ( (owner == None) || (owner == SDL_Window) )
+			{
+				owner = DefaultRootWindow(SDL_Display);
+				selection = XA_CUT_BUFFER0;
+			}
+			else
+			{
+				int selection_response = 0;
+				SDL_Event event;
+
+				owner = SDL_Window;
+				Lock_Display();
+				selection = XInternAtom(SDL_Display, "SDL_SELECTION", False);
+				XConvertSelection(SDL_Display, XA_PRIMARY, XA_STRING,
+						selection, owner, CurrentTime);
+				Unlock_Display();
+				while ( ! selection_response )
+				{
+					SDL_WaitEvent(&event);
+					if ( event.type == SDL_SYSWMEVENT )
+					{
+						XEvent xevent = event.syswm.msg->event.xevent;
+
+						if ( (xevent.type == SelectionNotify) &&
+								(xevent.xselection.requestor == owner) )
+							selection_response = 1;
+					}
+				}
+			}
+			Lock_Display();
+			if ( XGetWindowProperty(SDL_Display, owner, selection, 0, INT_MAX/4,
+						False, XA_STRING, &seln_type, &seln_format,
+						&nbytes, &overflow, &src) == Success )
+			{
+				if ( seln_type == XA_STRING )
+				{
+					strncpy(text, src, strlength);
+					retval = nbytes;
+				}
+				XFree(src);
+			}
+			Unlock_Display();
+
+			SDL_EventState(SDL_SYSWMEVENT, SDL_DISABLE);
+		}
+		//else
+		//	SDL is not running on X11
+
+	}
+
+	return retval;
+}
diff -urbBwN d1x.orig/arch/sdl/makefile d1x/arch/sdl/makefile
--- d1x.orig/arch/sdl/makefile	2000-01-17 06:58:38.000000000 +0100
+++ d1x/arch/sdl/makefile	2005-08-04 14:37:08.000000000 +0200
@@ -9,7 +9,7 @@
 endif
 
 ifdef SDL_INPUT
-OBJECTS += event.$(OBJ) key_arch.$(OBJ) mouse.$(OBJ)
+OBJECTS += event.$(OBJ) key_arch.$(OBJ) mouse.$(OBJ) clipboard.$(OBJ)
 endif
 
 ifdef SDL_VIDEO
diff -urbBwN d1x.orig/include/clipboard.h d1x/include/clipboard.h
--- d1x.orig/include/clipboard.h	1970-01-01 01:00:00.000000000 +0100
+++ d1x/include/clipboard.h	2005-08-04 14:37:42.000000000 +0200
@@ -0,0 +1,9 @@
+#ifndef _CLIPBOARD_H
+#define _CLIPBOARD_H
+
+#define MAX_PASTE_SIZE 36
+
+// fills the specified buffer with clipboard text. returns number chars copied
+extern int getClipboardText(char *text, int strlength);
+
+#endif
diff -urbBwN d1x.orig/main/credits.c d1x/main/credits.c
--- d1x.orig/main/credits.c	2005-07-31 11:47:39.000000000 +0200
+++ d1x/main/credits.c	2005-08-04 14:37:08.000000000 +0200
@@ -11,14 +11,17 @@
 COPYRIGHT 1993-1998 PARALLAX SOFTWARE CORPORATION.  ALL RIGHTS RESERVED.
 */
 /*
- * $Source: /usr/src/cvsroot/d1x/main/credits.c,v $
- * $Revision: 1.3 $
+ * $Source: /var/cvs/d1x/d1x/main/credits.c,v $
+ * $Revision: 1.4 $
  * $Author: donut $
- * $Date: 1999/11/20 10:05:16 $
+ * $Date: 2001/07/27 19:54:35 $
  * 
  * Routines to display the credits.
  * 
  * $Log: credits.c,v $
+ * Revision 1.4  2001/07/27 19:54:35  donut
+ * fix minor memleaks in credits
+ *
  * Revision 1.3  1999/11/20 10:05:16  donut
  * variable size menu patch from Jan Bobrowski.  Variable menu font size support and a bunch of fixes for menus that didn't work quite right, by me (MPM).
  *
@@ -150,7 +153,7 @@
 
 #ifdef RCS
 #pragma off (unreferenced)
-static char rcsid[] = "$Id: credits.c,v 1.3 1999/11/20 10:05:16 donut Exp $";
+static char rcsid[] = "$Id: credits.c,v 1.4 2001/07/27 19:54:35 donut Exp $";
 #pragma on (unreferenced)
 #endif
 
@@ -230,18 +233,8 @@
 	ROW_SPACING=names_font->ft_h+1;
 	
 	l = SHEIGHT;
-	fade_values_scalled = malloc(l);
-	scale_line(fade_values, fade_values_scalled, 200, l);//hey, why not?  Its just a one dimensional bitmap :) -MPM
-	
-//	memset(fade_values_scalled, 31, l);
-//	memcpy(fade_values_scalled, fade_values, 100);
-//	memcpy(fade_values_scalled+l-100, fade_values+100, 100);
 	set_screen_mode(SCREEN_MENU);
 	num_lines = l/ROW_SPACING + 1;
-	buffer = malloc(num_lines*80);// l*80); <--typo? -MPM
-
-	// Clear out all tex buffer lines.
-	for (i=0; i<num_lines; i++ ) buffer[i][0] = 0;
 
 	have_bin_file = 0;
 	file = cfopen( "credits.tex", "rb" );
@@ -260,6 +253,16 @@
 		return;
 	}
 
+	fade_values_scalled = malloc(l);
+	scale_line(fade_values, fade_values_scalled, 200, l);//hey, why not?  Its just a one dimensional bitmap :) -MPM
+//	memset(fade_values_scalled, 31, l);
+//	memcpy(fade_values_scalled, fade_values, 100);
+//	memcpy(fade_values_scalled+l-100, fade_values+100, 100);
+	
+	buffer = malloc(num_lines*80);
+	// Clear out all tex buffer lines.
+	for (i=0; i<num_lines; i++ ) buffer[i][0] = 0;
+
 	songs_play_song( SONG_CREDITS, 0 );
 
 	gr_remap_bitmap_good( &backdrop,backdrop_palette, -1, -1 );
diff -urbBwN d1x.orig/main/game.c d1x/main/game.c
--- d1x.orig/main/game.c	2005-07-31 11:47:39.000000000 +0200
+++ d1x/main/game.c	2005-08-04 14:37:08.000000000 +0200
@@ -1333,6 +1333,7 @@
 	//added 2000/06/19 Matthew Mueller - hack to fix "infinite toggle" problem
 	//it seems to be that the screen mode change takes long enough that the key has already sent repeat codes, or that its unpress event gets dropped, etc.  This is a somewhat ugly fix, but it works.
 	generic_key_handler(KEY_PADENTER,0);
+	generic_key_handler(KEY_ENTER,0);
 	key_flush();
 	//end addition -MM
 	return i;
diff -urbBwN d1x.orig/main/kmatrix.c d1x/main/kmatrix.c
--- d1x.orig/main/kmatrix.c	1999-06-15 00:08:16.000000000 +0200
+++ d1x/main/kmatrix.c	2005-08-04 14:37:08.000000000 +0200
@@ -11,14 +11,17 @@
 COPYRIGHT 1993-1998 PARALLAX SOFTWARE CORPORATION.  ALL RIGHTS RESERVED.
 */
 /*
- * $Source: /usr/src/cvsroot/d1x/main/kmatrix.c,v $
- * $Revision: 1.1.1.1 $
+ * $Source: /var/cvs/d1x/d1x/main/kmatrix.c,v $
+ * $Revision: 1.2 $
  * $Author: donut $
- * $Date: 1999/06/14 22:08:16 $
+ * $Date: 2002/03/26 22:10:09 $
  * 
  * Kill matrix displayed at end of level.
  * 
  * $Log: kmatrix.c,v $
+ * Revision 1.2  2002/03/26 22:10:09  donut
+ * fix multiplayer endlevel score display in high res
+ *
  * Revision 1.1.1.1  1999/06/14 22:08:16  donut
  * Import of d1x 1.37 source.
  *
@@ -99,7 +102,7 @@
 
 #ifdef RCS
 #pragma off (unreferenced)
-static char rcsid[] = "$Id: kmatrix.c,v 1.1.1.1 1999/06/14 22:08:16 donut Exp $";
+static char rcsid[] = "$Id: kmatrix.c,v 1.2 2002/03/26 22:10:09 donut Exp $";
 #pragma on (unreferenced)
 #endif
 
@@ -139,6 +142,16 @@
 #include "hudlog.h"
 //end addition -MM
 
+static int rescale_x(int x)
+{
+	return x * GWIDTH / 320;
+}
+
+static int rescale_y(int y)
+{
+	return y * GHEIGHT / 200;
+}
+
 #define CENTERING_OFFSET(x) ((300 - (70 + (x)*25 ))/2)
 
 int kmatrix_kills_changed = 0;
@@ -147,15 +160,15 @@
 {
 	int j, x, y;
 
-	y = 50+i*9;
+	y = rescale_y(50+i*9);
 
 	// Print player name.
 
-	gr_printf( CENTERING_OFFSET(N_players), y, "%s", Players[sorted[i]].callsign );
+	gr_printf( rescale_x(CENTERING_OFFSET(N_players)), y, "%s", Players[sorted[i]].callsign );
 
 	for (j=0; j<N_players; j++) {
 
-		x = 70 + CENTERING_OFFSET(N_players) + j*25;
+		x = rescale_x(70 + CENTERING_OFFSET(N_players) + j*25);
 
 		if (sorted[i]==sorted[j]) {
 			if (kill_matrix[sorted[i]][sorted[j]] == 0) {
@@ -177,7 +190,7 @@
 
 	}
 	
-	x = 70 + CENTERING_OFFSET(N_players) + N_players*25;
+	x = rescale_x(70 + CENTERING_OFFSET(N_players) + N_players*25);
 	gr_set_fontcolor( BM_XRGB(25,25,25),-1 );
 	gr_printf( x ,y,"%4d",Players[sorted[i]].net_kills_total);
 }
@@ -195,14 +208,14 @@
 		else
 			color = sorted[j];
 
-		x = 70 + CENTERING_OFFSET(N_players) + j*25;
+		x = rescale_x(70 + CENTERING_OFFSET(N_players) + j*25);
 		gr_set_fontcolor(gr_getcolor(player_rgb[color].r,player_rgb[color].g,player_rgb[color].b),-1 );
-		gr_printf( x, 40, "%c", Players[sorted[j]].callsign[0] );
+		gr_printf( x, rescale_y(40), "%c", Players[sorted[j]].callsign[0] );
 	}
 
-	x = 70 + CENTERING_OFFSET(N_players) + N_players*25;
+	x = rescale_x(70 + CENTERING_OFFSET(N_players) + N_players*25);
 	gr_set_fontcolor( BM_XRGB(31,31,31),-1 );
-	gr_printf( x, 40, TXT_KILLS);
+	gr_printf( x, rescale_y(40), TXT_KILLS);
 
 		
 }
@@ -212,26 +225,26 @@
 {
 	int j, x, y;
 	
-	y = 55 + N_players * 9;
+	y = rescale_y(55 + N_players * 9);
 
 //	gr_set_fontcolor(gr_getcolor(player_rgb[j].r,player_rgb[j].g,player_rgb[j].b),-1 );
 	gr_set_fontcolor( BM_XRGB(31,31,31),-1 );
 
-	x = CENTERING_OFFSET(N_players);
+	x = rescale_x(CENTERING_OFFSET(N_players));
 	gr_printf( x, y, TXT_DEATHS );
 
 	for (j=0; j<N_players; j++) {
-		x = 70 + CENTERING_OFFSET(N_players) + j*25;
+		x = rescale_x(70 + CENTERING_OFFSET(N_players) + j*25);
 		gr_printf( x, y, "%d", Players[sorted[j]].net_killed_total );
 	}
 
-	y = 55 + 72 + 12;
-	x = 35;
+	y = rescale_y(55 + 72 + 12);
+	x = rescale_x(35);
 
 	{
 		int sw, sh, aw;
 		gr_get_string_size(TXT_PRESS_ANY_KEY2, &sw, &sh, &aw);	
-		gr_printf( 160-(sw/2), y, TXT_PRESS_ANY_KEY2);
+		gr_printf( rescale_x(160)-(sw/2), y, TXT_PRESS_ANY_KEY2);
 	}
 }
 
@@ -246,12 +259,12 @@
 
 	gr_set_current_canvas(NULL);
 	
-	pcx_error = pcx_read_bitmap("STARS.PCX",&grd_curcanv->cv_bitmap,grd_curcanv->cv_bitmap.bm_type,NULL);
+	pcx_error = pcx_read_fullscr("STARS.PCX", NULL);
 	Assert(pcx_error == PCX_ERROR_NONE);
 
 	grd_curcanv->cv_font = Gamefonts[GFONT_MEDIUM_3];
 
-	gr_string( 0x8000, 15, TXT_KILL_MATRIX_TITLE	);
+	gr_string( 0x8000, rescale_y(15), TXT_KILL_MATRIX_TITLE	);
 
 	grd_curcanv->cv_font = Gamefonts[GFONT_SMALL];
 
diff -urbBwN d1x.orig/main/newmenu.c d1x/main/newmenu.c
--- d1x.orig/main/newmenu.c	2005-08-03 19:29:19.000000000 +0200
+++ d1x/main/newmenu.c	2005-08-04 14:37:08.000000000 +0200
@@ -11,14 +11,17 @@
 COPYRIGHT 1993-1998 PARALLAX SOFTWARE CORPORATION.  ALL RIGHTS RESERVED.
 */
 /*
- * $Source: /usr/src/cvsroot/d1x/main/newmenu.c,v $
- * $Revision: 1.13 $
+ * $Source: /var/cvs/d1x/d1x/main/newmenu.c,v $
+ * $Revision: 1.14 $
  * $Author: donut $
- * $Date: 2000/10/28 10:02:48 $
+ * $Date: 2003/06/27 10:06:59 $
  * 
  * Routines for menus.
  * 
  * $Log: newmenu.c,v $
+ * Revision 1.14  2003/06/27 10:06:59  donut
+ * make keypad enter numbers in input fields, and allow pasting from clipboard (patch from sekmu)
+ *
  * Revision 1.13  2000/10/28 10:02:48  donut
  * scale menu bevels too
  *
@@ -518,7 +521,7 @@
 
 #ifdef RCS
 #pragma off (unreferenced)
-static char rcsid[] = "$Id: newmenu.c,v 1.13 2000/10/28 10:02:48 donut Exp $";
+static char rcsid[] = "$Id: newmenu.c,v 1.14 2003/06/27 10:06:59 donut Exp $";
 #pragma on (unreferenced)
 #endif
 
@@ -528,6 +531,8 @@
 #include <stdarg.h>
 #include <ctype.h>
 
+#include "clipboard.h"
+
 #include "error.h"
 #include "types.h"
 #include "gr.h"
@@ -1288,6 +1293,21 @@
 
 		k = key_inkey();
 
+                switch( k )
+                {
+                  case KEY_PAD0: k = KEY_0;  break;
+                  case KEY_PAD1: k = KEY_1;  break;
+                  case KEY_PAD2: k = KEY_2;  break;
+                  case KEY_PAD3: k = KEY_3;  break;
+                  case KEY_PAD4: k = KEY_4;  break;
+                  case KEY_PAD5: k = KEY_5;  break;
+                  case KEY_PAD6: k = KEY_6;  break;
+                  case KEY_PAD7: k = KEY_7;  break;
+                  case KEY_PAD8: k = KEY_8;  break;
+                  case KEY_PAD9: k = KEY_9;  break;
+                  case KEY_PADPERIOD: k = KEY_PERIOD; break;
+                }
+
 		if (subfunction)
 			(*subfunction)(nitems,item,&k,choice);
 
@@ -1327,6 +1347,45 @@
 		old_choice = choice;
 	
 		switch( k )	{
+		case KEY_V + KEY_CTRLED:
+                case KEY_INSERT + KEY_SHIFTED:
+                          if(item[choice].type==NM_TYPE_INPUT)
+                           {
+                            char cbtext[MAX_PASTE_SIZE+1];
+                            memset(cbtext,0,MAX_PASTE_SIZE+1);
+                            int ret = getClipboardText(cbtext,MAX_PASTE_SIZE);
+                              if(ret)
+                               {
+                                int idx;
+
+                                  if (item[choice].value==-1)
+                                   {
+                                     item[choice].value = 0;
+                                   }
+
+                                  for(idx = 0 ; (idx < ret) && (item[choice].value < item[choice].text_len ) ; idx++ )
+                                   {
+                                    int ascii = cbtext[idx];
+                                    int allowed;
+
+                                     allowed = char_allowed(ascii);
+                                      if (!allowed && ascii==' ' && char_allowed('_'))
+                                       {
+                                         ascii = '_';
+                                         allowed=1;
+                                       }
+
+                                      if (allowed)
+                                       {
+                                         item[choice].text[item[choice].value++] = ascii;
+                                         item[choice].text[item[choice].value] = 0;
+                                         item[choice].redraw=1;	
+                                       }
+                                   }
+                                 k = -1;
+                               }
+                           }
+                        break;
 		case KEY_TAB + KEY_SHIFTED:
 		case KEY_UP:
 		case KEY_PAD8:
@@ -1437,7 +1496,7 @@
 
 		}
 
-		if ( choice > -1 )	{
+		if ( (choice > -1) && (k != -1))	{
 			int ascii;
 
 			if ( ((item[choice].type==NM_TYPE_INPUT)||((item[choice].type==NM_TYPE_INPUT_MENU)&&(item[choice].group==1)) )&& (old_choice==choice) )	{
